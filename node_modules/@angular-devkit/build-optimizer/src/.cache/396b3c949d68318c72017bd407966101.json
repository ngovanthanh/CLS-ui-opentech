{"remainingRequest":"/home/ict/cloudstack-ui/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/ict/cloudstack-ui/node_modules/@ng-idle/core/src/idle.js","dependencies":[{"path":"/home/ict/cloudstack-ui/node_modules/@ng-idle/core/src/idle.js","mtime":1522328033000},{"path":"/home/ict/cloudstack-ui/node_modules/cache-loader/dist/cjs.js","mtime":1534015689334},{"path":"/home/ict/cloudstack-ui/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { EventEmitter, Injectable, NgZone, Optional } from '@angular/core';\nimport { IdleExpiry } from './idleexpiry';\nimport { Interrupt } from './interrupt';\nimport { KeepaliveSvc } from './keepalivesvc';\nimport { LocalStorageExpiry } from './localstorageexpiry';\n/*\n * Indicates the desired auto resume behavior.\n */\n/*\n * Indicates the desired auto resume behavior.\n */\nexport var AutoResume;\n/*\n * Indicates the desired auto resume behavior.\n */\n(function (AutoResume) {\n    /*\n     * Auto resume functionality will be disabled.\n     */\n    AutoResume[AutoResume[\"disabled\"] = 0] = \"disabled\";\n    /*\n     * Can resume automatically even if they are idle.\n     */\n    AutoResume[AutoResume[\"idle\"] = 1] = \"idle\";\n    /*\n     * Can only resume automatically if they are not yet idle.\n     */\n    AutoResume[AutoResume[\"notIdle\"] = 2] = \"notIdle\";\n})(AutoResume || (AutoResume = {}));\n/**\n * A service for detecting and responding to user idleness.\n */\nvar Idle = /*@__PURE__*/ (function () {\n    function Idle(expiry, zone, keepaliveSvc) {\n        this.expiry = expiry;\n        this.zone = zone;\n        this.idle = 20 * 60;\n        this.timeoutVal = 30;\n        this.autoResume = AutoResume.idle;\n        this.interrupts = new Array;\n        this.running = false;\n        this.keepaliveEnabled = false;\n        this.onIdleStart = new EventEmitter;\n        this.onIdleEnd = new EventEmitter;\n        this.onTimeoutWarning = new EventEmitter();\n        this.onTimeout = new EventEmitter();\n        this.onInterrupt = new EventEmitter;\n        if (keepaliveSvc) {\n            this.keepaliveSvc = keepaliveSvc;\n            this.keepaliveEnabled = true;\n        }\n        this.setIdling(false);\n    }\n    /*\n     * Sets the idle name for localStorage.\n     * Important to set if multiple instances of Idle with LocalStorageExpiry\n     * @param The name of the idle.\n     */\n    /*\n       * Sets the idle name for localStorage.\n       * Important to set if multiple instances of Idle with LocalStorageExpiry\n       * @param The name of the idle.\n       */\n    Idle.prototype.setIdleName = /*\n       * Sets the idle name for localStorage.\n       * Important to set if multiple instances of Idle with LocalStorageExpiry\n       * @param The name of the idle.\n       */\n        function (key) {\n            if (this.expiry instanceof LocalStorageExpiry) {\n                this.expiry.setIdleName(key);\n            }\n            else {\n                throw new Error('Cannot set expiry key name because no LocalStorageExpiry has been provided.');\n            }\n        };\n    /*\n     * Returns whether or not keepalive integration is enabled.\n     * @return True if integration is enabled; otherwise, false.\n     */\n    /*\n       * Returns whether or not keepalive integration is enabled.\n       * @return True if integration is enabled; otherwise, false.\n       */\n    Idle.prototype.getKeepaliveEnabled = /*\n       * Returns whether or not keepalive integration is enabled.\n       * @return True if integration is enabled; otherwise, false.\n       */\n        function () {\n            return this.keepaliveEnabled;\n        };\n    /*\n     * Sets and returns whether or not keepalive integration is enabled.\n     * @param True if the integration is enabled; otherwise, false.\n     * @return The current value.\n     */\n    /*\n       * Sets and returns whether or not keepalive integration is enabled.\n       * @param True if the integration is enabled; otherwise, false.\n       * @return The current value.\n       */\n    Idle.prototype.setKeepaliveEnabled = /*\n       * Sets and returns whether or not keepalive integration is enabled.\n       * @param True if the integration is enabled; otherwise, false.\n       * @return The current value.\n       */\n        function (value) {\n            if (!this.keepaliveSvc) {\n                throw new Error('Cannot enable keepalive integration because no KeepaliveSvc has been provided.');\n            }\n            return this.keepaliveEnabled = value;\n        };\n    /*\n     * Returns the current timeout value.\n     * @return The timeout value in seconds.\n     */\n    /*\n       * Returns the current timeout value.\n       * @return The timeout value in seconds.\n       */\n    Idle.prototype.getTimeout = /*\n       * Returns the current timeout value.\n       * @return The timeout value in seconds.\n       */\n        function () {\n            return this.timeoutVal;\n        };\n    /*\n     * Sets the timeout value.\n     * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n     * @return The current value. If disabled, the value will be 0.\n     */\n    /*\n       * Sets the timeout value.\n       * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n       * @return The current value. If disabled, the value will be 0.\n       */\n    Idle.prototype.setTimeout = /*\n       * Sets the timeout value.\n       * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n       * @return The current value. If disabled, the value will be 0.\n       */\n        function (seconds) {\n            if (seconds === false) {\n                this.timeoutVal = 0;\n            }\n            else if (typeof seconds === 'number' && seconds >= 0) {\n                this.timeoutVal = seconds;\n            }\n            else {\n                throw new Error('\\'seconds\\' can only be \\'false\\' or a positive number.');\n            }\n            return this.timeoutVal;\n        };\n    /*\n     * Returns the current idle value.\n     * @return The idle value in seconds.\n     */\n    /*\n       * Returns the current idle value.\n       * @return The idle value in seconds.\n       */\n    Idle.prototype.getIdle = /*\n       * Returns the current idle value.\n       * @return The idle value in seconds.\n       */\n        function () {\n            return this.idle;\n        };\n    /*\n     * Sets the idle value.\n     * @param seconds - The idle value in seconds.\n     * @return The idle value in seconds.\n     */\n    /*\n       * Sets the idle value.\n       * @param seconds - The idle value in seconds.\n       * @return The idle value in seconds.\n       */\n    Idle.prototype.setIdle = /*\n       * Sets the idle value.\n       * @param seconds - The idle value in seconds.\n       * @return The idle value in seconds.\n       */\n        function (seconds) {\n            if (seconds <= 0) {\n                throw new Error('\\'seconds\\' must be greater zero');\n            }\n            return this.idle = seconds;\n        };\n    /*\n     * Returns the current autoresume value.\n     * @return The current value.\n     */\n    /*\n       * Returns the current autoresume value.\n       * @return The current value.\n       */\n    Idle.prototype.getAutoResume = /*\n       * Returns the current autoresume value.\n       * @return The current value.\n       */\n        function () {\n            return this.autoResume;\n        };\n    Idle.prototype.setAutoResume = function (value) {\n        return this.autoResume = value;\n    };\n    /*\n     * Sets interrupts from the specified sources.\n     * @param sources - Interrupt sources.\n     * @return The resulting interrupts.\n     */\n    /*\n       * Sets interrupts from the specified sources.\n       * @param sources - Interrupt sources.\n       * @return The resulting interrupts.\n       */\n    Idle.prototype.setInterrupts = /*\n       * Sets interrupts from the specified sources.\n       * @param sources - Interrupt sources.\n       * @return The resulting interrupts.\n       */\n        function (sources) {\n            this.clearInterrupts();\n            var self = this;\n            for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n                var source = sources_1[_i];\n                var sub = new Interrupt(source);\n                sub.subscribe(function (args) {\n                    self.interrupt(args.force, args.innerArgs);\n                });\n                this.interrupts.push(sub);\n            }\n            return this.interrupts;\n        };\n    /*\n     * Returns the current interrupts.\n     * @return The current interrupts.\n     */\n    /*\n       * Returns the current interrupts.\n       * @return The current interrupts.\n       */\n    Idle.prototype.getInterrupts = /*\n       * Returns the current interrupts.\n       * @return The current interrupts.\n       */\n        function () {\n            return this.interrupts;\n        };\n    /*\n     * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n     */\n    /*\n       * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n       */\n    Idle.prototype.clearInterrupts = /*\n       * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n       */\n        function () {\n            for (var _i = 0, _a = this.interrupts; _i < _a.length; _i++) {\n                var sub = _a[_i];\n                sub.pause();\n                sub.unsubscribe();\n            }\n            this.interrupts.length = 0;\n        };\n    /*\n     * Returns whether or not the service is running i.e. watching for idleness.\n     * @return True if service is watching; otherwise, false.\n     */\n    /*\n       * Returns whether or not the service is running i.e. watching for idleness.\n       * @return True if service is watching; otherwise, false.\n       */\n    Idle.prototype.isRunning = /*\n       * Returns whether or not the service is running i.e. watching for idleness.\n       * @return True if service is watching; otherwise, false.\n       */\n        function () {\n            return this.running;\n        };\n    /*\n     * Returns whether or not the user is considered idle.\n     * @return True if the user is in the idle state; otherwise, false.\n     */\n    /*\n       * Returns whether or not the user is considered idle.\n       * @return True if the user is in the idle state; otherwise, false.\n       */\n    Idle.prototype.isIdling = /*\n       * Returns whether or not the user is considered idle.\n       * @return True if the user is in the idle state; otherwise, false.\n       */\n        function () {\n            return this.idling;\n        };\n    /*\n     * Starts watching for inactivity.\n     */\n    /*\n       * Starts watching for inactivity.\n       */\n    Idle.prototype.watch = /*\n       * Starts watching for inactivity.\n       */\n        function (skipExpiry) {\n            var _this = this;\n            this.safeClearInterval('idleHandle');\n            this.safeClearInterval('timeoutHandle');\n            var timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n            if (!skipExpiry) {\n                var value = new Date(this.expiry.now().getTime() + ((this.idle + timeout) * 1000));\n                this.expiry.last(value);\n            }\n            if (this.idling) {\n                this.toggleState();\n            }\n            if (!this.running) {\n                this.startKeepalive();\n                this.toggleInterrupts(true);\n            }\n            this.running = true;\n            var watchFn = function () {\n                _this.zone.run(function () {\n                    var diff = _this.getExpiryDiff(timeout);\n                    if (diff > 0) {\n                        _this.safeClearInterval('idleHandle');\n                        _this.setIdleIntervalOutsideOfZone(watchFn, diff);\n                    }\n                    else {\n                        _this.toggleState();\n                    }\n                });\n            };\n            this.setIdleIntervalOutsideOfZone(watchFn, this.idle * 1000);\n        };\n    /*\n     * Allows protractor tests to call waitForAngular without hanging\n     */\n    /*\n       * Allows protractor tests to call waitForAngular without hanging\n       */\n    Idle.prototype.setIdleIntervalOutsideOfZone = /*\n       * Allows protractor tests to call waitForAngular without hanging\n       */\n        function (watchFn, frequency) {\n            var _this = this;\n            this.zone.runOutsideAngular(function () {\n                _this.idleHandle = setInterval(watchFn, frequency);\n            });\n        };\n    /*\n     * Stops watching for inactivity.\n     */\n    /*\n       * Stops watching for inactivity.\n       */\n    Idle.prototype.stop = /*\n       * Stops watching for inactivity.\n       */\n        function () {\n            this.stopKeepalive();\n            this.toggleInterrupts(false);\n            this.safeClearInterval('idleHandle');\n            this.safeClearInterval('timeoutHandle');\n            this.setIdling(false);\n            this.running = false;\n            this.expiry.last(null);\n        };\n    /*\n     * Forces a timeout event and state.\n     */\n    /*\n       * Forces a timeout event and state.\n       */\n    Idle.prototype.timeout = /*\n       * Forces a timeout event and state.\n       */\n        function () {\n            this.stopKeepalive();\n            this.toggleInterrupts(false);\n            this.safeClearInterval('idleHandle');\n            this.safeClearInterval('timeoutHandle');\n            this.setIdling(true);\n            this.running = false;\n            this.countdown = 0;\n            this.onTimeout.emit(null);\n        };\n    /*\n     * Signals that user activity has occurred.\n     * @param force - Forces watch to be called, unless they are timed out.\n     * @param eventArgs - Optional source event arguments.\n     */\n    /*\n       * Signals that user activity has occurred.\n       * @param force - Forces watch to be called, unless they are timed out.\n       * @param eventArgs - Optional source event arguments.\n       */\n    Idle.prototype.interrupt = /*\n       * Signals that user activity has occurred.\n       * @param force - Forces watch to be called, unless they are timed out.\n       * @param eventArgs - Optional source event arguments.\n       */\n        function (force, eventArgs) {\n            if (!this.running) {\n                return;\n            }\n            if (this.timeoutVal && this.expiry.isExpired()) {\n                this.timeout();\n                return;\n            }\n            this.onInterrupt.emit(eventArgs);\n            if (force === true || this.autoResume === AutoResume.idle ||\n                (this.autoResume === AutoResume.notIdle && !this.expiry.idling())) {\n                this.watch(force);\n            }\n        };\n    Idle.prototype.setIdling = function (value) {\n        this.idling = value;\n        this.expiry.idling(value);\n    };\n    Idle.prototype.toggleState = function () {\n        var _this = this;\n        this.setIdling(!this.idling);\n        if (this.idling) {\n            this.onIdleStart.emit(null);\n            this.stopKeepalive();\n            if (this.timeoutVal > 0) {\n                this.countdown = this.timeoutVal;\n                this.doCountdown();\n                this.setTimoutIntervalOutsideZone(function () {\n                    _this.doCountdownInZone();\n                }, 1000);\n            }\n        }\n        else {\n            this.toggleInterrupts(true);\n            this.onIdleEnd.emit(null);\n            this.startKeepalive();\n        }\n        this.safeClearInterval('idleHandle');\n    };\n    Idle.prototype.setTimoutIntervalOutsideZone = function (intervalFn, frequency) {\n        var _this = this;\n        this.zone.runOutsideAngular(function () {\n            _this.timeoutHandle = setInterval(function () {\n                intervalFn();\n            }, frequency);\n        });\n    };\n    Idle.prototype.toggleInterrupts = function (resume) {\n        for (var _i = 0, _a = this.interrupts; _i < _a.length; _i++) {\n            var interrupt = _a[_i];\n            if (resume) {\n                interrupt.resume();\n            }\n            else {\n                interrupt.pause();\n            }\n        }\n    };\n    Idle.prototype.getExpiryDiff = function (timeout) {\n        var now = this.expiry.now();\n        var last = this.expiry.last() || now;\n        return last.getTime() - now.getTime() - (timeout * 1000);\n    };\n    Idle.prototype.doCountdownInZone = function () {\n        var _this = this;\n        this.zone.run(function () {\n            _this.doCountdown();\n        });\n    };\n    Idle.prototype.doCountdown = function () {\n        var timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n        var diff = this.getExpiryDiff(timeout);\n        if (diff > 0) {\n            this.safeClearInterval('timeoutHandle');\n            this.interrupt(true);\n            return;\n        }\n        if (!this.idling) {\n            return;\n        }\n        if (this.countdown <= 0) {\n            this.timeout();\n            return;\n        }\n        this.onTimeoutWarning.emit(this.countdown);\n        this.countdown--;\n    };\n    Idle.prototype.safeClearInterval = function (handleName) {\n        var handle = this[handleName];\n        if (handle !== null && typeof handle !== 'undefined') {\n            clearInterval(this[handleName]);\n            this[handleName] = null;\n        }\n    };\n    Idle.prototype.startKeepalive = function () {\n        if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n            return;\n        }\n        if (this.running) {\n            this.keepaliveSvc.ping();\n        }\n        this.keepaliveSvc.start();\n    };\n    Idle.prototype.stopKeepalive = function () {\n        if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n            return;\n        }\n        this.keepaliveSvc.stop();\n    };\n    /*\n     * Called by Angular when destroying the instance.\n     */\n    /*\n       * Called by Angular when destroying the instance.\n       */\n    Idle.prototype.ngOnDestroy = /*\n       * Called by Angular when destroying the instance.\n       */\n        function () {\n            this.stop();\n            this.clearInterrupts();\n        };\n    return Idle;\n}());\nexport { Idle };\n//# sourceMappingURL=idle.js.map \n",null]}