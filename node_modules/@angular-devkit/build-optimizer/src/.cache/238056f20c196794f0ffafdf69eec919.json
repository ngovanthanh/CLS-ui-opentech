{"remainingRequest":"/home/ict/cloudstack-ui/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/ict/cloudstack-ui/node_modules/@ngrx/effects/@ngrx/effects.es5.js","dependencies":[{"path":"/home/ict/cloudstack-ui/node_modules/@ngrx/effects/@ngrx/effects.es5.js","mtime":1520433289000},{"path":"/home/ict/cloudstack-ui/node_modules/cache-loader/dist/cjs.js","mtime":1534015689334},{"path":"/home/ict/cloudstack-ui/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ScannedActionsSubject, Store, StoreFeatureModule, StoreRootModule, compose } from '@ngrx/store';\nimport { merge as merge$1 } from 'rxjs/observable/merge';\nimport { ignoreElements as ignoreElements$1 } from 'rxjs/operator/ignoreElements';\nimport { materialize as materialize$1 } from 'rxjs/operator/materialize';\nimport { map as map$1 } from 'rxjs/operator/map';\nimport { ErrorHandler, Inject, Injectable, InjectionToken, NgModule, Optional } from '@angular/core';\nimport { Observable as Observable$1 } from 'rxjs/Observable';\nimport { filter } from 'rxjs/operators';\nimport { groupBy as groupBy$1 } from 'rxjs/operator/groupBy';\nimport { mergeMap as mergeMap$1 } from 'rxjs/operator/mergeMap';\nimport { exhaustMap as exhaustMap$1 } from 'rxjs/operator/exhaustMap';\nimport { dematerialize as dematerialize$1 } from 'rxjs/operator/dematerialize';\nimport { filter as filter$2 } from 'rxjs/operator/filter';\nimport { Subject as Subject$1 } from 'rxjs/Subject';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar METADATA_KEY = '__@ngrx/effects__';\n/**\n * @record\n */\n/**\n * @param {?} sourceProto\n * @return {?}\n */\nfunction getEffectMetadataEntries(sourceProto) {\n    return sourceProto.constructor[METADATA_KEY] || [];\n}\n/**\n * @param {?} sourceProto\n * @param {?} entries\n * @return {?}\n */\nfunction setEffectMetadataEntries(sourceProto, entries) {\n    var /** @type {?} */ constructor = sourceProto.constructor;\n    var /** @type {?} */ meta = constructor.hasOwnProperty(METADATA_KEY)\n        ? ((constructor))[METADATA_KEY]\n        : Object.defineProperty(constructor, METADATA_KEY, { value: [] })[METADATA_KEY];\n    Array.prototype.push.apply(meta, entries);\n}\n/**\n * @param {?=} __0\n * @return {?}\n */\nfunction Effect(_a) {\n    var dispatch = (_a === void 0 ? { dispatch: true } : _a).dispatch;\n    return /** @type {?} */ (function (target, propertyName) {\n        var /** @type {?} */ metadata = { propertyName: propertyName, dispatch: dispatch };\n        setEffectMetadataEntries(target, [metadata]);\n    } /*TODO(#823)*/);\n}\n/**\n * @param {?} instance\n * @return {?}\n */\nfunction getSourceForInstance(instance) {\n    return Object.getPrototypeOf(instance);\n}\nvar getSourceMetadata = compose(getEffectMetadataEntries, getSourceForInstance);\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getEffectsMetadata(instance) {\n    var /** @type {?} */ metadata = {};\n    getSourceMetadata(instance).forEach(function (_a) {\n        var propertyName = _a.propertyName, dispatch = _a.dispatch;\n        ((metadata))[propertyName] = { dispatch: dispatch };\n    });\n    return metadata;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @record\n */\nvar onRunEffectsKey = 'ngrxOnRunEffects';\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nfunction isOnRunEffects(sourceInstance) {\n    var /** @type {?} */ source = getSourceForInstance(sourceInstance);\n    return (onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nfunction mergeEffects(sourceInstance) {\n    var /** @type {?} */ sourceName = getSourceForInstance(sourceInstance).constructor.name;\n    var /** @type {?} */ observables = getSourceMetadata(sourceInstance).map(function (_a) {\n        var propertyName = _a.propertyName, dispatch = _a.dispatch;\n        var /** @type {?} */ observable = typeof sourceInstance[propertyName] === 'function'\n            ? sourceInstance[propertyName]()\n            : sourceInstance[propertyName];\n        if (dispatch === false) {\n            return ignoreElements$1.call(observable);\n        }\n        var /** @type {?} */ materialized$ = materialize$1.call(observable);\n        return map$1.call(materialized$, function (notification) {\n            return ({\n                effect: sourceInstance[propertyName],\n                notification: notification,\n                propertyName: propertyName,\n                sourceName: sourceName,\n                sourceInstance: sourceInstance,\n            });\n        });\n    });\n    return merge$1.apply(void 0, observables);\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nfunction resolveEffectSource(sourceInstance) {\n    var /** @type {?} */ mergedEffects$ = mergeEffects(sourceInstance);\n    if (isOnRunEffects(sourceInstance)) {\n        return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n    return mergedEffects$;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar Actions = /*@__PURE__*/ (function (_super) {\n    __extends(Actions, _super);\n    /**\n     * @param {?=} source\n     */\n    function Actions(source) {\n        var _this = _super.call(this) || this;\n        if (source) {\n            _this.source = source;\n        }\n        return _this;\n    }\n    /**\n     * @template R\n     * @param {?} operator\n     * @return {?}\n     */\n    Actions.prototype.lift = function (operator) {\n        var /** @type {?} */ observable = new Actions();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * @template V2\n     * @param {...?} allowedTypes\n     * @return {?}\n     */\n    Actions.prototype.ofType = function () {\n        var allowedTypes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            allowedTypes[_i] = arguments[_i];\n        }\n        return /** @type {?} */ (ofType.apply(void 0, allowedTypes)(/** @type {?} */ (this)));\n    };\n    return Actions;\n}(Observable$1));\n/**\n * @template T\n * @param {...?} allowedTypes\n * @return {?}\n */\nfunction ofType() {\n    var allowedTypes = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        allowedTypes[_i] = arguments[_i];\n    }\n    return filter(function (action) { return allowedTypes.some(function (type) { return type === action.type; }); });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @record\n */\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction verifyOutput(output, reporter) {\n    reportErrorThrown(output, reporter);\n    reportInvalidActions(output, reporter);\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction reportErrorThrown(output, reporter) {\n    if (output.notification.kind === 'E') {\n        reporter.handleError(output.notification.error);\n    }\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction reportInvalidActions(output, reporter) {\n    if (output.notification.kind === 'N') {\n        var /** @type {?} */ action = output.notification.value;\n        var /** @type {?} */ isInvalidAction = !isAction(action);\n        if (isInvalidAction) {\n            reporter.handleError(new Error(\"Effect \" + getEffectName(output) + \" dispatched an invalid action: \" + action));\n        }\n    }\n}\n/**\n * @param {?} action\n * @return {?}\n */\nfunction isAction(action) {\n    return action && action.type && typeof action.type === 'string';\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getEffectName(_a) {\n    var propertyName = _a.propertyName, sourceInstance = _a.sourceInstance, sourceName = _a.sourceName;\n    var /** @type {?} */ isMethod = typeof sourceInstance[propertyName] === 'function';\n    return \"\\\"\" + sourceName + \".\" + propertyName + (isMethod ? '()' : '') + \"\\\"\";\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar EffectSources = /*@__PURE__*/ (function (_super) {\n    __extends(EffectSources, _super);\n    /**\n     * @param {?} errorHandler\n     */\n    function EffectSources(errorHandler) {\n        var _this = _super.call(this) || this;\n        _this.errorHandler = errorHandler;\n        return _this;\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n    EffectSources.prototype.addEffects = function (effectSourceInstance) {\n        this.next(effectSourceInstance);\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    EffectSources.prototype.toActions = function () {\n        var _this = this;\n        return mergeMap$1.call(groupBy$1.call(this, getSourceForInstance), function (source$) {\n            return dematerialize$1.call(filter$2.call(map$1.call(exhaustMap$1.call(source$, resolveEffectSource), function (output) {\n                verifyOutput(output, _this.errorHandler);\n                return output.notification;\n            }), function (notification) { return notification.kind === 'N'; }));\n        });\n    };\n    return EffectSources;\n}(Subject$1));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar IMMEDIATE_EFFECTS = new InjectionToken('ngrx/effects: Immediate Effects');\nvar ROOT_EFFECTS = new InjectionToken('ngrx/effects: Root Effects');\nvar FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Feature Effects');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar EffectsRunner = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} effectSources\n     * @param {?} store\n     */\n    function EffectsRunner(effectSources, store$$1) {\n        this.effectSources = effectSources;\n        this.store = store$$1;\n        this.effectsSubscription = null;\n    }\n    /**\n     * @return {?}\n     */\n    EffectsRunner.prototype.start = function () {\n        if (!this.effectsSubscription) {\n            this.effectsSubscription = this.effectSources\n                .toActions()\n                .subscribe(this.store);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EffectsRunner.prototype.ngOnDestroy = function () {\n        if (this.effectsSubscription) {\n            this.effectsSubscription.unsubscribe();\n            this.effectsSubscription = null;\n        }\n    };\n    return EffectsRunner;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nvar EffectsRootModule = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} sources\n     * @param {?} runner\n     * @param {?} store\n     * @param {?} rootEffects\n     * @param {?} storeRootModule\n     * @param {?} storeFeatureModule\n     */\n    function EffectsRootModule(sources, runner, store$$1, rootEffects, storeRootModule, storeFeatureModule) {\n        this.sources = sources;\n        runner.start();\n        rootEffects.forEach(function (effectSourceInstance) { return sources.addEffects(effectSourceInstance); });\n        store$$1.dispatch({ type: ROOT_EFFECTS_INIT });\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n    EffectsRootModule.prototype.addEffects = function (effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n    };\n    return EffectsRootModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar EffectsFeatureModule = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} root\n     * @param {?} effectSourceGroups\n     * @param {?} storeRootModule\n     * @param {?} storeFeatureModule\n     */\n    function EffectsFeatureModule(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n        this.root = root;\n        effectSourceGroups.forEach(function (group) { return group.forEach(function (effectSourceInstance) { return root.addEffects(effectSourceInstance); }); });\n    }\n    return EffectsFeatureModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar EffectsModule = /*@__PURE__*/ (function () {\n    function EffectsModule() {\n    }\n    /**\n     * @param {?} featureEffects\n     * @return {?}\n     */\n    EffectsModule.forFeature = function (featureEffects) {\n        return {\n            ngModule: EffectsFeatureModule,\n            providers: [\n                featureEffects,\n                {\n                    provide: FEATURE_EFFECTS,\n                    multi: true,\n                    deps: featureEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    };\n    /**\n     * @param {?} rootEffects\n     * @return {?}\n     */\n    EffectsModule.forRoot = function (rootEffects) {\n        return {\n            ngModule: EffectsRootModule,\n            providers: [\n                EffectsRunner,\n                EffectSources,\n                Actions,\n                rootEffects,\n                {\n                    provide: ROOT_EFFECTS,\n                    deps: rootEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    };\n    return EffectsModule;\n}());\n/**\n * @param {...?} instances\n * @return {?}\n */\nfunction createSourceInstances() {\n    var instances = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        instances[_i] = arguments[_i];\n    }\n    return instances;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { Effect, getEffectsMetadata, mergeEffects, Actions, ofType, EffectsModule, EffectSources, ROOT_EFFECTS_INIT, EffectsFeatureModule as ɵc, createSourceInstances as ɵa, EffectsRootModule as ɵb, EffectsRunner as ɵf, FEATURE_EFFECTS as ɵe, ROOT_EFFECTS as ɵd };\n//# sourceMappingURL=effects.es5.js.map\n",null]}